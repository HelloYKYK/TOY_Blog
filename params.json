{
  "name": "Android开发_静态内部类_使用的必要性",
  "tagline": "work and study",
  "body": "###解释静态内部类存在的必要性\r\n\r\n> 我们经常说,Android开发中要避免静态变量的使用,但是为什么要避免静态变量的使用和静态方法的创建呢?这个周末,才了解其用心:\r\n\r\n```java\r\npublic class MainActivity extends AppCompatActivity {\r\n    private static TestResource mResource = null;\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n        if(mResource == null){\r\n            mResource = new TestResource();\r\n        }\r\n        //...\r\n    }\r\n    class TestResource {\r\n    //...\r\n    }\r\n}\r\n```\r\n---\r\n 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：\r\n ---\r\n* 将该内部类设为静态内部类\r\n* 或将该内部类抽取出来封装成一个单例\r\n* 如果需要使用Context，请使用ApplicationContext\r\n\r\n---\r\n\r\n>* 避免使用静态常量是为了避免我们的静态常量持有了外部类的引用,比如上面这个例子,这个静态的实例就会一直持有Activity的引用,导致Activity的内存资源不能正常回收\r\n>* 避免使用静态方法这方面,搜索了很多,最后得到的结论是,其实静态方法和普通方法占用内存和加载时机是一样的,这方面来说,并不影响效率.\r\n\r\n----\r\n>并且,我从资料中还看到Gson解析的时候如果发现内部类不是static修饰,经常会出错!\r\n\r\n----\r\n\r\n以上可以看出,使用静态内部类是必要的!\r\n原因有2:\r\n* 1.避免内存泄漏\r\n* 2.避免json解析出错",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}